"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountService = void 0;
const common_1 = require("@nestjs/common");
const prisma_service_1 = require("../common/prisma.service");
const utils_1 = require("../common/utils");
let AccountService = class AccountService {
    constructor(prisma) {
        this.prisma = prisma;
    }
    async invite(InvitationDto) {
        try {
            const appId = InvitationDto['appId'];
            const emails = InvitationDto['emails'];
            const respObj = {};
            const account = this.prisma.account.findFirst({
                where: {
                    appId,
                },
            });
            if (account == null) {
                respObj.success = false;
                respObj.message = 'Account Doesn Not Exist';
            }
            for (const i in emails) {
                const email = i;
                let user = await this.prisma.user.findFirst({
                    where: {
                        email,
                    },
                });
                if (user == null) {
                    user = await this.prisma.user.create({
                        data: {
                            email,
                            uniqueId: utils_1.TruUtil.generateRandomString(),
                            name: '',
                        },
                    });
                }
                const userAccount = await this.prisma.userAccount.findFirst({
                    where: {
                        user,
                        account,
                    },
                });
                if (userAccount == null) {
                    await this.prisma.userAccount.create({
                        data: {
                            user,
                            account,
                            status: 'CONFIRMATION_PENDING',
                        },
                    });
                }
                else {
                    await this.prisma.userAccount.update({
                        where: {
                            id: userAccount.id,
                        },
                        data: {
                            status: 'CONFIRMATION_PENDING',
                        },
                    });
                }
            }
            return {
                message: 'Invites Send Successfully',
                success: true,
            };
        }
        catch (error) {
            console.log('Invite Error In team members');
            console.log(error);
            throw new common_1.HttpException('Server Error', common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async discard(discardInviteDto) {
        try {
            const { email, appId } = discardInviteDto;
            const user = await this.prisma.user.findFirst({
                where: {
                    email,
                },
            });
            if (user == null) {
                return {
                    status: 404,
                    success: false,
                    message: "User Doesn't exist.",
                };
            }
            const account = await this.prisma.account.findFirst({
                where: {
                    appId,
                },
            });
            await this.prisma.userAccount.updateMany({
                where: {
                    user,
                    account,
                },
                data: {
                    status: 'INACTIVE',
                },
            });
            return {
                status: 200,
                success: true,
                message: 'Request Discarded Successfully',
            };
        }
        catch (error) {
            console.log('Discard Error In team members');
            console.log(error);
            throw new common_1.HttpException('Server Error', common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async inviteInfo(inviteObj) {
        try {
            const { appId, uniqueId } = inviteObj;
            const user = await this.prisma.user.findFirst({
                where: {
                    uniqueId,
                },
                select: {
                    name: true,
                    email: true,
                    uniqueId: true,
                    status: true,
                },
            });
            if (user == null) {
                throw new common_1.HttpException('User Not Found', common_1.HttpStatus.NOT_FOUND);
            }
            const account = await this.prisma.account.findFirst({
                where: {
                    appId,
                },
                select: {
                    name: true,
                },
            });
            if (account == null) {
                throw new common_1.HttpException('Account Not Found', common_1.HttpStatus.NOT_FOUND);
            }
            const responseObj = {};
            responseObj.accountName = account.name;
            responseObj.user = Object.assign({}, user);
            return {
                success: true,
                message: 'User Info',
                data: Object.assign({}, responseObj),
            };
        }
        catch (error) {
            console.log('Discard Error In team members');
            console.log(error);
            throw new common_1.HttpException('Server Error', common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async acceptInvite(acceptObj, isLoggedIn, userData) {
        const user = await this.prisma.user.findFirst({
            where: {
                uniqueId: acceptObj.uniqueId,
            },
        });
        const account = await this.prisma.account.findFirst({
            where: {
                appId: acceptObj.appId,
            },
        });
        let status = false;
        if (user == null || account == null) {
            console.log("User Doesn't Exist");
            console.log('Invalid Invitation');
            throw new common_1.HttpException('Invalid Invitation', common_1.HttpStatus.BAD_REQUEST);
        }
        if (isLoggedIn) {
            if (userData.email !== user.email) {
                console.log('Unauthorized Session');
                throw new common_1.HttpException('Unauthorized Session', common_1.HttpStatus.FORBIDDEN);
            }
            const { password } = acceptObj;
            if (utils_1.TruUtil.getHash(utils_1.TruUtil.decode(password)) !== user.password) {
                console.log('Invalid User');
                throw new common_1.HttpException('Invalid User', common_1.HttpStatus.UNAUTHORIZED);
            }
        }
        else {
            if (user.password == null) {
                if (acceptObj.password !== acceptObj.confirmPassword) {
                    console.log('Password Dont match');
                    throw new common_1.HttpException('Password Dont match', common_1.HttpStatus.BAD_REQUEST);
                }
                await this.prisma.user.updateMany({
                    where: {
                        id: user.id,
                    },
                    data: {
                        password: utils_1.TruUtil.getHash(utils_1.TruUtil.decode(acceptObj.password)),
                        confirmedAt: new Date(),
                        status: 'ACTIVE',
                    },
                });
            }
        }
        status = true;
        await this.prisma.userAccount.updateMany({
            where: {
                user,
                account,
            },
            data: {
                status: 'CONFIRMED',
                updatedAt: new Date(),
            },
        });
        return {
            success: status,
            message: 'Invited Accepted Successfully',
        };
    }
};
AccountService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [prisma_service_1.PrismaService])
], AccountService);
exports.AccountService = AccountService;
//# sourceMappingURL=account.service.js.map